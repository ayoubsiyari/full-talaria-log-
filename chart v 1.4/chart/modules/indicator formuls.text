ðŸ§­ TREND INDICATORS
1. Simple Moving Average (SMA)
function SMA(values, period) {
  return values.map((v, i, arr) => 
    i >= period - 1 ? arr.slice(i - period + 1, i + 1).reduce((a,b)=>a+b)/period : null
  );
}

2. Exponential Moving Average (EMA)
function EMA(values, period) {
  const k = 2 / (period + 1);
  let ema = [];
  values.forEach((v, i) => {
    if (i === 0) ema.push(v);
    else ema.push(v * k + ema[i - 1] * (1 - k));
  });
  return ema;
}

3. MACD (Moving Average Convergence Divergence)
function MACD(values, fast=12, slow=26, signal=9) {
  const fastEMA = EMA(values, fast);
  const slowEMA = EMA(values, slow);
  const macdLine = fastEMA.map((v, i) => v - slowEMA[i]);
  const signalLine = EMA(macdLine, signal);
  const histogram = macdLine.map((v, i) => v - signalLine[i]);
  return { macdLine, signalLine, histogram };
}

4. Parabolic SAR
// Simplified version
function ParabolicSAR(high, low, step=0.02, max=0.2) {
  let psar = [low[0]], ep = high[0], af = step, uptrend = true;
  for (let i = 1; i < high.length; i++) {
    psar[i] = psar[i-1] + af * (ep - psar[i-1]);
    if (uptrend) {
      if (low[i] < psar[i]) { uptrend = false; psar[i] = ep; ep = low[i]; af = step; }
      else if (high[i] > ep) { ep = high[i]; af = Math.min(af + step, max); }
    } else {
      if (high[i] > psar[i]) { uptrend = true; psar[i] = ep; ep = high[i]; af = step; }
      else if (low[i] < ep) { ep = low[i]; af = Math.min(af + step, max); }
    }
  }
  return psar;
}

5. Average Directional Index (ADX)
function ADX(high, low, close, period=14) {
  const plusDM = [], minusDM = [], tr = [];
  for (let i=1;i<high.length;i++){
    const upMove = high[i]-high[i-1], downMove = low[i-1]-low[i];
    plusDM.push(upMove>downMove && upMove>0 ? upMove : 0);
    minusDM.push(downMove>upMove && downMove>0 ? downMove : 0);
    tr.push(Math.max(high[i]-low[i], Math.abs(high[i]-close[i-1]), Math.abs(low[i]-close[i-1])));
  }
  const ATR = EMA(tr, period);
  const plusDI = plusDM.map((v,i)=>100*(EMA(plusDM,period)[i]/ATR[i]));
  const minusDI = minusDM.map((v,i)=>100*(EMA(minusDM,period)[i]/ATR[i]));
  const dx = plusDI.map((v,i)=>100*Math.abs(v-minusDI[i])/(v+minusDI[i]));
  return EMA(dx, period);
}

6. Ichimoku Cloud
function Ichimoku(high, low, close) {
  const conv = high.map((v,i)=> (Math.max(...high.slice(i-8,i+1)) + Math.min(...low.slice(i-8,i+1)))/2);
  const base = high.map((v,i)=> (Math.max(...high.slice(i-25,i+1)) + Math.min(...low.slice(i-25,i+1)))/2);
  const spanA = conv.map((v,i)=>(v+base[i])/2);
  const spanB = high.map((v,i)=> (Math.max(...high.slice(i-51,i+1)) + Math.min(...low.slice(i-51,i+1)))/2);
  return { conversion: conv, base, spanA, spanB };
}

âš¡ MOMENTUM INDICATORS
7. Relative Strength Index (RSI)
function RSI(values, period=14) {
  let gains=[], losses=[];
  for(let i=1;i<values.length;i++){
    const diff = values[i]-values[i-1];
    gains.push(Math.max(diff,0));
    losses.push(Math.max(-diff,0));
  }
  const avgGain = EMA(gains, period);
  const avgLoss = EMA(losses, period);
  return avgGain.map((g,i)=>100 - (100/(1 + g/avgLoss[i])));
}

8. Stochastic Oscillator
function Stochastic(high, low, close, kPeriod=14, dPeriod=3) {
  const k = close.map((v,i)=> {
    const minLow = Math.min(...low.slice(Math.max(0,i-kPeriod+1), i+1));
    const maxHigh = Math.max(...high.slice(Math.max(0,i-kPeriod+1), i+1));
    return 100 * (v - minLow) / (maxHigh - minLow);
  });
  const d = SMA(k, dPeriod);
  return { k, d };
}

9. Commodity Channel Index (CCI)
function CCI(high, low, close, period=20) {
  const tp = close.map((v,i)=>(high[i]+low[i]+close[i])/3);
  const sma = SMA(tp, period);
  return tp.map((v,i)=>(v - sma[i]) / (0.015 * SMA(tp.map((x,j)=>Math.abs(x-sma[j])),period)[i]));
}

10. Rate of Change (ROC)
function ROC(values, period=12) {
  return values.map((v,i)=> i>=period ? ((v - values[i-period]) / values[i-period]) * 100 : null);
}

11. Momentum
function Momentum(values, period=10) {
  return values.map((v,i)=> i>=period ? v - values[i-period] : null);
}

ðŸŒŠ VOLATILITY INDICATORS
12. Bollinger Bands
function BollingerBands(values, period=20, mult=2) {
  const ma = SMA(values, period);
  const std = values.map((v,i)=>{
    if (i<period-1) return null;
    const slice = values.slice(i-period+1,i+1);
    const mean = ma[i];
    const variance = slice.reduce((a,b)=>a+Math.pow(b-mean,2),0)/period;
    return Math.sqrt(variance);
  });
  return {
    upper: ma.map((v,i)=>v + mult*std[i]),
    middle: ma,
    lower: ma.map((v,i)=>v - mult*std[i])
  };
}

13. Average True Range (ATR)
function ATR(high, low, close, period=14) {
  const tr = [];
  for (let i=1;i<high.length;i++){
    tr.push(Math.max(high[i]-low[i], Math.abs(high[i]-close[i-1]), Math.abs(low[i]-close[i-1])));
  }
  return EMA(tr, period);
}

14. Keltner Channel
function Keltner(high, low, close, period=20, mult=2) {
  const ema = EMA(close, period);
  const atr = ATR(high, low, close, period);
  return {
    upper: ema.map((v,i)=>v + mult*atr[i]),
    middle: ema,
    lower: ema.map((v,i)=>v - mult*atr[i])
  };
}

15. Donchian Channel
function Donchian(high, low, period=20) {
  return {
    upper: high.map((v,i)=>Math.max(...high.slice(Math.max(0,i-period+1), i+1))),
    lower: low.map((v,i)=>Math.min(...low.slice(Math.max(0,i-period+1), i+1)))
  };
}

ðŸ“Š VOLUME INDICATORS
16. On-Balance Volume (OBV)
function OBV(close, volume) {
  let obv = [0];
  for(let i=1;i<close.length;i++){
    if(close[i]>close[i-1]) obv.push(obv[i-1]+volume[i]);
    else if(close[i]<close[i-1]) obv.push(obv[i-1]-volume[i]);
    else obv.push(obv[i-1]);
  }
  return obv;
}

17. Accumulation/Distribution Line (A/D)
function ADL(high, low, close, volume) {
  let adl = [0];
  for (let i=1;i<close.length;i++){
    const mfm = ((close[i]-low[i]) - (high[i]-close[i])) / (high[i]-low[i]);
    adl.push(adl[i-1] + (mfm * volume[i]));
  }
  return adl;
}

18. Chaikin Money Flow (CMF)
function CMF(high, low, close, volume, period=20) {
  const mfv = close.map((v,i)=>{
    const mfm = ((close[i]-low[i]) - (high[i]-close[i])) / (high[i]-low[i]);
    return mfm * volume[i];
  });
  return mfv.map((v,i)=> {
    if (i<period-1) return null;
    const mfvSum = mfv.slice(i-period+1,i+1).reduce((a,b)=>a+b,0);
    const volSum = volume.slice(i-period+1,i+1).reduce((a,b)=>a+b,0);
    return mfvSum / volSum;
  });
}

19. Money Flow Index (MFI)
function MFI(high, low, close, volume, period=14) {
  const tp = close.map((v,i)=>(high[i]+low[i]+close[i])/3);
  let pos=[], neg=[];
  for(let i=1;i<tp.length;i++){
    const flow = tp[i]*volume[i];
    if(tp[i]>tp[i-1]) pos.push(flow); else neg.push(flow);
  }
  const posSum = SMA(pos, period);
  const negSum = SMA(neg, period);
  return posSum.map((v,i)=>100 - (100/(1 + (v/negSum[i]))));
}

20. Volume Weighted Average Price (VWAP)
function VWAP(high, low, close, volume) {
  let cumPV = 0, cumV = 0, vwap = [];
  for (let i=0;i<close.length;i++){
    const tp = (high[i]+low[i]+close[i])/3;
    cumPV += tp * volume[i];
    cumV += volume[i];
    vwap.push(cumPV / cumV);
  }
  return vwap;
}

ðŸ§  EXTRA / ADVANCED INDICATORS
21. Hull Moving Average (HMA)
function HMA(values, period=16) {
  const half = Math.floor(period/2);
  const sqrt = Math.floor(Math.sqrt(period));
  const wma = (arr,p)=>arr.map((_,i)=> {
    if(i<p-1) return null;
    const slice = arr.slice(i-p+1,i+1);
    const denom = p*(p+1)/2;
    return slice.reduce((a,b,j)=>a+b*(j+1),0)/denom;
  });
  const wma1 = wma(values, half);
  const wma2 = wma(values, period);
  const diff = wma1.map((v,i)=>2*v - wma2[i]);
  return wma(diff, sqrt);
}

22. SuperTrend
function SuperTrend(high, low, close, period=10, mult=3) {
  const atr = ATR(high, low, close, period);
  const hl2 = high.map((v,i)=>(high[i]+low[i])/2);
  let upper = [], lower = [], trend = [];
  for(let i=0;i<hl2.length;i++){
    upper[i] = hl2[i] + mult*atr[i];
    lower[i] = hl2[i] - mult*atr[i];
  }
  let inUptrend = true;
  for(let i=1;i<hl2.length;i++){
    if(close[i]>upper[i-1]) inUptrend=true;
    else if(close[i]<lower[i-1]) inUptrend=false;
    trend[i] = inUptrend ? lower[i] : upper[i];
  }
  return trend;
}

23. Williams %R
function WilliamsR(high, low, close, period=14) {
  return close.map((v,i)=>{
    const hh = Math.max(...high.slice(Math.max(0,i-period+1),i+1));
    const ll = Math.min(...low.slice(Math.max(0,i-period+1),i+1));
    return ((hh - v) / (hh - ll)) * -100;
  });
}

24. Pivot Points (Classic)
function PivotPoints(high, low, close) {
  const pp = (high[high.length-1] + low[low.length-1] + close[close.length-1]) / 3;
  const r1 = (2*pp) - low[low.length-1];
  const s1 = (2*pp) - high[high.length-1];
  const r2 = pp + (high[high.length-1] - low[low.length-1]);
  const s2 = pp - (high[high.length-1] - low[low.length-1]);
  return { pp, r1, s1, r2, s2 };
}

25. Heikin Ashi (alternative candles)
function HeikinAshi(open, high, low, close) {
  let haOpen = [ (open[0] + close[0]) / 2 ], haClose=[], haHigh=[], haLow=[];
  for(let i=0;i<close.length;i++){
    haClose[i]=(open[i]+high[i]+low[i]+close[i])/4;
    haOpen[i]=i===0?haOpen[0]:(haOpen[i-1]+haClose[i-1])/2;
    haHigh[i]=Math.max(high[i],haOpen[i],haClose[i]);
    haLow[i]=Math.min(low[i],haOpen[i],haClose[i]);
  }
  return { haOpen, haHigh, haLow, haClose };
}

26. ZigZag
function ZigZag(close, threshold=5) {
  let result=[close[0]];
  for(let i=1;i<close.length;i++){
    const change = (close[i]-close[i-1])/close[i-1]*100;
    if(Math.abs(change)>=threshold) result.push(close[i]);
    else result.push(null);
  }
  return result;
}

27. Detrended Price Oscillator (DPO)
function DPO(close, period=20) {
  const sma = SMA(close, period);
  const shift = Math.floor(period/2)+1;
  return close.map((v,i)=>i>=shift? v - sma[i-shift]: null);
}

28. Envelope Bands
function Envelopes(close, period=20, percent=0.02) {
  const ma = SMA(close, period);
  return {
    upper: ma.map(v=>v*(1+percent)),
    lower: ma.map(v=>v*(1-percent))
  };
}

29. Triple EMA (TEMA)
function TEMA(values, period=30) {
  const e1 = EMA(values, period);
  const e2 = EMA(e1, period);
  const e3 = EMA(e2, period);
  return e1.map((v,i)=>3*v - 3*e2[i] + e3[i]);
}

30. Volume Oscillator
function VolumeOscillator(volume, short=5, long=20) {
  const shortEMA = EMA(volume, short);
  const longEMA = EMA(volume, long);
  return shortEMA.map((v,i)=>100*(v-longEMA[i])/longEMA[i]);
}
